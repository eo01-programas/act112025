<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Defectos por Máquina - Control de Calidad</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React y Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- ExcelJS para Excel con mejor soporte de estilos -->
    <script src="https://cdn.jsdelivr.net/npm/exceljs@4.3.0/dist/exceljs.min.js"></script>
    
    <!-- Librería para leer Excel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <style>
        body { font-family: Arial, sans-serif; }
        
        /* Ocultar spinners en inputs number */
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        /* Estilos para botones de filtro */
        .filter-btn {
            transition: all 0.2s ease;
        }
        .filter-btn:hover {
            transform: translateY(-1px);
        }
        .filter-btn.active {
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }

        @media print {
            @page { size: landscape; margin: 1cm; }
            * {
                margin: 0 !important;
                padding: 0 !important;
            }
            body { 
                background: white; 
                -webkit-print-color-adjust: exact; 
                print-color-adjust: exact;
                margin: 0 !important;
                padding: 0 !important;
            }
            #root {
                margin: 0 !important;
                padding: 0 !important;
            }
            .print\:hidden { display: none !important; }
            table { width: 100% !important; border-collapse: collapse; }
            thead { display: table-header-group; }
            tfoot { display: table-footer-group; }
            tr { page-break-inside: avoid; }
            th, td { padding: 2px 3px !important; font-size: 8px !important; }
            header { page-break-after: avoid; }
            .max-h-screen { max-height: none !important; height: auto !important; }
            /* Grid: 1fr para grupos, 5fr para tabla */
            div[style*="calc(100vh"] { height: auto !important; }
            .grid { display: grid !important; }
            .grid.grid-cols-1 { grid-template-columns: 1fr 5fr !important; gap: 8px !important; }
            .lg\:col-span-5 { grid-column: auto !important; }
            /* Permitir scroll en impresión */
            div[style*="maxHeight"] { max-height: none !important; height: auto !important; overflow: visible !important; }
            /* Asegurar que la tabla sea visible */
            .overflow-auto { overflow: visible !important; }
            .overflow-hidden { overflow: visible !important; }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div id="root"></div>

    <!-- Botón flotante volver al menú principal -->
    <a href="index.html" title="Volver al menú principal" style="position:fixed;right:18px;top:18px;width:50px;height:50px;border-radius:50%;background:#001a54;color:#fff;display:flex;align-items:center;justify-content:center;z-index:1100;box-shadow:0 6px 20px rgba(0,0,0,.18);text-decoration:none;font-size:22px;transition:background .2s" onmouseover="this.style.background='#1a3a7a'" onmouseout="this.style.background='#001a54'">&#8592;</a>

    <!-- Modal de carga -->
    <div id="loading-modal" class="fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl shadow-xl p-6 max-w-sm w-full mx-4 text-center">
            <div id="modal-spinner" class="mb-4 relative">
                <div class="inline-block animate-spin rounded-full h-12 w-12 border-4 border-blue-200 border-t-blue-600"></div>
                <div id="modal-timer" class="absolute inset-0 flex items-center justify-center">
                    <span class="text-sm font-bold text-blue-600">--</span>
                </div>
            </div>
            <h3 id="modal-title" class="text-lg font-semibold text-gray-800 mb-1">Cargando...</h3>
            <p id="modal-message" class="text-gray-500 text-sm mb-3">Por favor espere</p>
            <div class="bg-gray-100 rounded-lg p-2 mb-3">
                <p id="modal-status" class="text-xs text-gray-500">Procesando...</p>
            </div>
            <p id="modal-time-remaining" class="text-xs text-gray-400 mb-3 hidden">Tiempo estimado: <span id="time-text">--</span></p>
            <button id="modal-close-btn" onclick="document.getElementById('loading-modal').classList.add('hidden'); document.getElementById('modal-spinner').classList.remove('hidden'); document.getElementById('modal-close-btn').classList.add('hidden'); stopModalTimer();" class="hidden bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-6 rounded-lg transition-colors text-sm">
                Cerrar
            </button>
        </div>
    </div>

    <script>
        // Timer global para el modal
        let modalTimerInterval = null;
        let modalTimeRemaining = 0;

        function startModalTimer(estimatedSeconds) {
            stopModalTimer();
            modalTimeRemaining = estimatedSeconds;
            
            const timerEl = document.getElementById('modal-timer').querySelector('span');
            const timeRemainingEl = document.getElementById('modal-time-remaining');
            const timeTextEl = document.getElementById('time-text');
            
            timeRemainingEl.classList.remove('hidden');
            
            const updateDisplay = () => {
                if (modalTimeRemaining > 0) {
                    timerEl.textContent = modalTimeRemaining + 's';
                    timeTextEl.textContent = modalTimeRemaining + ' segundos';
                } else {
                    timerEl.textContent = '...';
                    timeTextEl.textContent = 'finalizando...';
                }
            };
            
            updateDisplay();
            
            modalTimerInterval = setInterval(() => {
                modalTimeRemaining--;
                updateDisplay();
                
                if (modalTimeRemaining < -30) {
                    timeTextEl.textContent = 'tomando más de lo esperado...';
                }
            }, 1000);
        }

        function stopModalTimer() {
            if (modalTimerInterval) {
                clearInterval(modalTimerInterval);
                modalTimerInterval = null;
            }
            const timerEl = document.getElementById('modal-timer');
            if (timerEl) timerEl.querySelector('span').textContent = '✓';
            const timeRemainingEl = document.getElementById('modal-time-remaining');
            if (timeRemainingEl) timeRemainingEl.classList.add('hidden');
        }

        function resetModalTimer() {
            stopModalTimer();
            const timerEl = document.getElementById('modal-timer');
            if (timerEl) timerEl.querySelector('span').textContent = '--';
        }
    </script>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback } = React;

        // ============================================
        // CONFIGURACIÓN - URL DE APPS SCRIPT
        // ============================================
        const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbw_sS4m7Mll4uwpiMHImgvDKtZACt6J653r2fgeUFNSr1q0REGhncQeEW9nYUbrJeJo/exec";
        // ============================================

        // ============================================
        // CONFIGURACIÓN - CARGA RÁPIDA JSONP (Google Sheets público)
        // ============================================
        const SHEET_ID = "1NVfMymJadfFuV5ROJB9ZamsCkXjM6hVRAz_Yku1ce_w";
        const SHEET_NAME = "base";
        // ============================================

        // --- FUNCIONES DE CARGA RÁPIDA JSONP ---
        const gvizToObjects = (resp) => {
            if (!resp || !resp.table) return [];
            const cols = (resp.table.cols || []).map(c => String(c.label || c.id || "").trim());
            return (resp.table.rows || []).map(r => {
                const o = {};
                cols.forEach((h, i) => {
                    const cell = r.c && r.c[i];
                    o[h] = cell && (cell.v !== null && cell.v !== undefined) ? cell.v : "";
                });
                return o;
            });
        };

        const loadSheetJSONP = (sheetId, sheetName) => {
            const TIMEOUT_MS = 15000;
            return new Promise((resolve, reject) => {
                const cbName = "GVIZ_CB_" + Math.random().toString(36).slice(2);
                let script = document.createElement("script");
                let timer = null;

                function cleanup() {
                    if (timer) clearTimeout(timer);
                    if (script && script.parentNode) script.parentNode.removeChild(script);
                    if (window[cbName]) delete window[cbName];
                }

                timer = setTimeout(() => {
                    cleanup();
                    reject(new Error(`Tiempo de espera agotado al cargar "${sheetName}".`));
                }, TIMEOUT_MS);

                window[cbName] = function(resp) {
                    cleanup();
                    if (resp && resp.status === "error") {
                        reject(new Error(resp.errors?.[0]?.detailed_message || "Error al cargar datos."));
                    } else {
                        resolve(gvizToObjects(resp));
                    }
                };

                const base = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq`;
                const url = `${base}?sheet=${encodeURIComponent(sheetName)}&headers=2&tq=${encodeURIComponent("select *")}&tqx=out:json;responseHandler:${cbName}&nocache=${Date.now()}`;

                script.src = url;
                document.head.appendChild(script);
            });
        };

        // Función que intenta JSONP primero y Apps Script como fallback
        const loadSheetDataFast = async () => {
            // Verificar caché local primero (pero ignorar si tiene 0 registros)
            const cacheKey = 'all_data';
            const cached = clientCache.get(cacheKey);
            if (cached && cached.length > 0) {
                console.log(`[Cache] ✓ ${cached.length} registros desde caché`);
                return cached;
            } else if (cached && cached.length === 0) {
                console.log('[Cache] ⚠ Caché vacío detectado, recargando desde servidor...');
                clientCache.clear();
            }

            // Si hay SHEET_ID configurado, intentar JSONP primero
            if (SHEET_ID && SHEET_ID.length > 10) {
                try {
                    updateModalStatus('Cargando datos (JSONP)...');
                    console.log('[JSONP] Intentando carga rápida...');
                    const data = await loadSheetJSONP(SHEET_ID, SHEET_NAME);
                    if (data && data.length > 0) {
                        console.log(`[JSONP] ✓ Cargados ${data.length} registros`);
                        clientCache.set('all_data', data);
                        return data;
                    } else {
                        console.log('[JSONP] ⚠ No se recibieron datos, NO guardando en caché');
                    }
                } catch (err) {
                    console.log('[JSONP] Falló:', err.message);
                }
            }
            // Fallback a Apps Script
            updateModalStatus('Cargando datos (servidor)...');
            return await fetchAllData();
        };

        // ============================================
        // CACHÉ LOCAL CON SESSIONSTORAGE (persistente entre páginas)
        // ============================================
        class LocalCache {
            constructor(duration = 600000) {
                this.duration = duration;
                this.storageKey = 'calidad_textil_cache';
            }
            
            _getStorage() {
                try {
                    const stored = sessionStorage.getItem(this.storageKey);
                    return stored ? JSON.parse(stored) : {};
                } catch (e) {
                    return {};
                }
            }
            
            _setStorage(data) {
                try {
                    sessionStorage.setItem(this.storageKey, JSON.stringify(data));
                } catch (e) {
                    // Si sessionStorage está lleno, limpiar y reintentar
                    sessionStorage.clear();
                    try {
                        sessionStorage.setItem(this.storageKey, JSON.stringify(data));
                    } catch (e2) {
                        console.warn('No se pudo guardar en sessionStorage');
                    }
                }
            }
            
            get(key) {
                const storage = this._getStorage();
                const item = storage[key];
                if (!item) return null;
                
                if (Date.now() - item.timestamp > this.duration) {
                    delete storage[key];
                    this._setStorage(storage);
                    return null;
                }
                
                return item.data;
            }
            
            set(key, data) {
                const storage = this._getStorage();
                storage[key] = {
                    data: data,
                    timestamp: Date.now()
                };
                this._setStorage(storage);
            }
            
            clear() {
                sessionStorage.removeItem(this.storageKey);
            }
            
            clearPattern(pattern) {
                const storage = this._getStorage();
                let changed = false;
                for (const key of Object.keys(storage)) {
                    if (key.includes(pattern)) {
                        delete storage[key];
                        changed = true;
                    }
                }
                if (changed) this._setStorage(storage);
            }
        }
        
        const clientCache = new LocalCache(600000); // 10 minutos

        // --- COLUMNAS DE DEFECTOS ---
        const DEFECT_COLUMNS = [
            "Rotura De Aguja", "Quebradura en el Doblez", "Jaladuras", "Qebraduras", "Polipropileno",
            "Parada De Maquina", "Marca De Doblez", "Malla Rota", "Malla Retinada",
            "Malla Caida/Fuga", "Lineas Verticales De Aguja", "Lineas De Aceite",
            "Hueco Con Cordon", "Hilo Tensionado", "Hilo Sucio",
            "Hilo Jaspeado", "Hilo Irregular", "Hilo Doble", "Falla De Raport", "Hilo Barrado",
            "Gotas Aceite Dispersas", "Falla De Lycra a lo Ancho", "Falla De Lycra",
            "Escapes De Lycra", "Empalme2", "Empalme", "Cordon",
            "Contaminación De Hilado", "Cont. Por Ambiente", "Cascarillas",
            "Caida De Tela", "Anillado"
        ];

        // --- FUNCIONES DEL MODAL (con retardo de 5s) ---
        let modalShowTimeout = null;
        let modalPendingConfig = null;

        const _actuallyShowModal = () => {
            if (!modalPendingConfig) return;
            const { title, message, status, estimatedSeconds } = modalPendingConfig;
            resetModalTimer();
            document.getElementById('modal-spinner').classList.remove('hidden');
            document.getElementById('modal-close-btn').classList.add('hidden');
            document.getElementById('modal-title').textContent = title || 'Cargando...';
            document.getElementById('modal-message').textContent = message || 'Por favor espere';
            document.getElementById('modal-status').textContent = status || 'Procesando...';
            document.getElementById('loading-modal').classList.remove('hidden');
            if (estimatedSeconds > 0) {
                startModalTimer(estimatedSeconds);
            }
        };

        const showLoadingModal = (title, message, status, estimatedSeconds = 0) => {
            if (modalShowTimeout) { clearTimeout(modalShowTimeout); modalShowTimeout = null; }
            modalPendingConfig = { title, message, status, estimatedSeconds };
            modalShowTimeout = setTimeout(_actuallyShowModal, 5000);
        };

        const updateModalStatus = (status) => {
            if (modalPendingConfig) modalPendingConfig.status = status;
            if (!document.getElementById('loading-modal').classList.contains('hidden')) {
                document.getElementById('modal-status').textContent = status;
            }
        };

        const hideLoadingModal = () => {
            if (modalShowTimeout) { clearTimeout(modalShowTimeout); modalShowTimeout = null; }
            modalPendingConfig = null;
            stopModalTimer();
            document.getElementById('loading-modal').classList.add('hidden');
        };

        const showModalError = (message, details) => {
            if (modalShowTimeout) { clearTimeout(modalShowTimeout); modalShowTimeout = null; }
            modalPendingConfig = null;
            stopModalTimer();
            document.getElementById('modal-spinner').classList.add('hidden');
            document.getElementById('modal-title').textContent = '❌ Error';
            document.getElementById('modal-message').textContent = message;
            document.getElementById('modal-status').textContent = details || 'Intente nuevamente';
            document.getElementById('modal-close-btn').classList.remove('hidden');
            document.getElementById('loading-modal').classList.remove('hidden');
        };

        const showModalSuccess = (message, details) => {
            if (modalShowTimeout) { clearTimeout(modalShowTimeout); modalShowTimeout = null; }
            modalPendingConfig = null;
            stopModalTimer();
            if (!document.getElementById('loading-modal').classList.contains('hidden')) {
                document.getElementById('modal-title').textContent = '✅ ¡Completado!';
                document.getElementById('modal-message').textContent = message;
                document.getElementById('modal-status').textContent = details;
                setTimeout(hideLoadingModal, 3000);
            }
        };

        // --- FUNCIONES DE UTILIDAD ---
        const formatDateForInput = (date) => {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        };

        // Función para calcular fechas dinámicas basadas en los datos
        const calculateDateRangeFromData = (allData) => {
            let maxDate = null;
            
            allData.forEach(row => {
                const rawDateStr = row['Día'] || row['Dia'] || row['Day'] || row['Fecha'] || '';
                // Intentar obtener el año de la columna 'Año' si existe
                const yearFromColumn = parseInt(row['Año'] || row['Anio'] || row['Year'] || 0);
                const rowDate = parseSheetDate(rawDateStr, yearFromColumn);
                if (rowDate) {
                    const dateNum = rowDate.year * 10000 + (rowDate.month + 1) * 100 + rowDate.day;
                    if (!maxDate || dateNum > maxDate.num) {
                        maxDate = { ...rowDate, num: dateNum };
                    }
                }
            });
            
            if (!maxDate) {
                // Fallback si no hay datos
                const today = new Date();
                const weekAgo = new Date(today);
                weekAgo.setDate(weekAgo.getDate() - 5);
                return {
                    endDate: formatDateForInput(today),
                    startDate: formatDateForInput(weekAgo)
                };
            }
            
            // Última fecha encontrada
            const endDateObj = new Date(maxDate.year, maxDate.month, maxDate.day);
            // 5 días antes
            const startDateObj = new Date(endDateObj);
            startDateObj.setDate(startDateObj.getDate() - 5);
            
            return {
                endDate: formatDateForInput(endDateObj),
                startDate: formatDateForInput(startDateObj)
            };
        };

        // Mapa de meses en inglés y español
        const mesesMapGlobal = {
            'ene': 0, 'enero': 0, 'jan': 0, 'january': 0,
            'feb': 1, 'febrero': 1, 'february': 1,
            'mar': 2, 'marzo': 2, 'march': 2,
            'abr': 3, 'abril': 3, 'apr': 3, 'april': 3,
            'may': 4, 'mayo': 4,
            'jun': 5, 'junio': 5, 'june': 5,
            'jul': 6, 'julio': 6, 'july': 6,
            'ago': 7, 'agosto': 7, 'aug': 7, 'august': 7,
            'sep': 8, 'sept': 8, 'septiembre': 8, 'september': 8,
            'oct': 9, 'octubre': 9, 'october': 9,
            'nov': 10, 'noviembre': 10, 'november': 10,
            'dic': 11, 'diciembre': 11, 'dec': 11, 'december': 11
        };

        // Parsear fecha del sheet (formato: dd/mmm/yyyy o variantes)
        // Retorna un objeto {year, month, day} para comparaciones sin problemas de timezone
        const parseSheetDate = (dateStr, fallbackYear = null) => {
            if (!dateStr) return null;
            
            const str = String(dateStr).trim().toLowerCase();
            
            // Formato dd-Mon (ej: 10-Jan) - común en JSONP
            const shortMatch = str.match(/^(\d{1,2})-([a-z]{3,})$/i);
            if (shortMatch) {
                const day = parseInt(shortMatch[1]);
                const monthStr = shortMatch[2].substring(0, 3).toLowerCase();
                const month = mesesMapGlobal[monthStr];
                // Usar año de la columna Año o el año actual
                const year = fallbackYear || new Date().getFullYear();
                if (month !== undefined && !isNaN(day)) {
                    return { year, month, day, asDate: new Date(year, month, day) };
                }
            }
            
            // Formato dd/mmm/yyyy (ej: 25/jul/2025)
            const match = str.match(/(\d{1,2})\/([a-z]{3,})\/(\d{4})/);
            if (match) {
                const day = parseInt(match[1]);
                const monthStr = match[2].substring(0, 3);
                const month = mesesMapGlobal[monthStr];
                const year = parseInt(match[3]);
                if (month !== undefined && !isNaN(day) && !isNaN(year)) {
                    return { year, month, day, asDate: new Date(year, month, day) };
                }
            }
            
            // Formato ISO: 2025-07-25T00:00:00.000Z o similar
            const isoMatch = str.match(/^(\d{4})-(\d{2})-(\d{2})/);
            if (isoMatch) {
                const year = parseInt(isoMatch[1]);
                const month = parseInt(isoMatch[2]) - 1; // Meses 0-indexed
                const day = parseInt(isoMatch[3]);
                return { year, month, day, asDate: new Date(year, month, day) };
            }
            
            // Formato dd/mm/yyyy (numérico)
            const numericMatch = str.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
            if (numericMatch) {
                const day = parseInt(numericMatch[1]);
                const month = parseInt(numericMatch[2]) - 1;
                const year = parseInt(numericMatch[3]);
                return { year, month, day, asDate: new Date(year, month, day) };
            }
            
            // Intentar parse directo como último recurso
            const parsed = new Date(dateStr);
            if (!isNaN(parsed.getTime())) {
                return { 
                    year: parsed.getFullYear(), 
                    month: parsed.getMonth(), 
                    day: parsed.getDate(),
                    asDate: parsed 
                };
            }
            
            return null;
        };
        
        // Comparar fechas de forma segura sin problemas de timezone
        const compareDates = (dateObj, startStr, endStr) => {
            if (!dateObj) return false;
            
            // Parsear las fechas de entrada (formato ISO yyyy-MM-dd)
            const [startYear, startMonth, startDay] = startStr.split('-').map(Number);
            const [endYear, endMonth, endDay] = endStr.split('-').map(Number);
            
            // Construir números para comparación YYYYMMDD
            const dateNum = dateObj.year * 10000 + (dateObj.month + 1) * 100 + dateObj.day;
            const startNum = startYear * 10000 + startMonth * 100 + startDay;
            const endNum = endYear * 10000 + endMonth * 100 + endDay;
            
            // Debug: descomenta para ver comparaciones
            // console.log(`Comparando: ${dateNum} entre ${startNum} y ${endNum} = ${dateNum >= startNum && dateNum <= endNum}`);
            
            return dateNum >= startNum && dateNum <= endNum;
        };

        // Extraer el grupo de una máquina (letras antes del guion)
        const extractGroup = (maquina) => {
            if (!maquina) return '';
            const match = String(maquina).match(/^([A-Za-z]+)/);
            return match ? match[1].toUpperCase() : '';
        };

        // --- FUNCIÓN PARA OBTENER DATOS POR RANGO DE FECHAS (OPTIMIZADA) ---
        // Ahora usa el filtrado del servidor que es más rápido
        const fetchDataByDateRange = async (startDate, endDate, opFilter = null) => {
            if (!APPS_SCRIPT_URL || APPS_SCRIPT_URL.includes("PEGAR_AQUI")) {
                return null;
            }

            // Verificar caché local primero
            const cacheKey = `daterange_${startDate}_${endDate}_${opFilter || 'all'}`;
            const cached = clientCache.get(cacheKey);
            if (cached) {
                updateModalStatus(`✓ ${cached.length} registro(s) cargado(s) desde caché local`);
                return cached;
            }

            try {
                // NUEVO: Usar el endpoint optimizado que filtra en el servidor
                let url = `${APPS_SCRIPT_URL}?action=getDataByDateRange&startDate=${encodeURIComponent(startDate)}&endDate=${encodeURIComponent(endDate)}`;
                if (opFilter) {
                    url += `&op=${encodeURIComponent(opFilter)}`;
                }
                console.log('fetchDataByDateRange url=', url);
                
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 60000); // 60 segundos timeout

                updateModalStatus('Consultando servidor...');
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeout);
                
                console.log('fetchDataByDateRange response.ok=', response.ok, 'status=', response.status);

                const text = await response.text();
                let result = null;
                try {
                    result = JSON.parse(text);
                } catch (err) {
                    console.log('fetchDataByDateRange - respuesta no JSON:', text.slice(0, 1000));
                }

                if (result && result.success && result.data) {
                    console.log(`Servidor devolvió ${result.data.length} registros filtrados`);
                    // Guardar en caché local
                    clientCache.set(cacheKey, result.data);
                    return result.data;
                }
                console.log('fetchDataByDateRange - no se recibió data válida', result);
            } catch (error) {
                console.log("Error obteniendo datos (getDataByDateRange):", error);
                if (error.name === 'AbortError') {
                    updateModalStatus('Tiempo de espera agotado. Intentando método alternativo...');
                }
            }
            return null;
        };

        // --- FUNCIÓN PARA OBTENER TODOS LOS DATOS (FALLBACK) ---
        const fetchAllData = async () => {
            if (!APPS_SCRIPT_URL || APPS_SCRIPT_URL.includes("PEGAR_AQUI")) {
                return null;
            }

            // Verificar caché local primero (pero ignorar si tiene 0 registros)
            const cacheKey = 'all_data';
            const cached = clientCache.get(cacheKey);
            if (cached && cached.length > 0) {
                updateModalStatus(`✓ ${cached.length} registro(s) cargado(s) desde caché local`);
                return cached;
            } else if (cached && cached.length === 0) {
                console.log('[Cache] ⚠ Caché vacío en fetchAllData, limpiando...');
                clientCache.clear();
            }

            try {
                const url = `${APPS_SCRIPT_URL}?action=getAllData`;
                console.log('fetchAllData url=', url);
                
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 90000); // 90 segundos para datos grandes

                updateModalStatus('Descargando todos los datos...');
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeout);
                
                console.log('fetchAllData response.ok=', response.ok, 'status=', response.status);

                const text = await response.text();
                console.log('fetchAllData - tamaño respuesta:', text.length, 'bytes');
                
                let result = null;
                try {
                    result = JSON.parse(text);
                } catch (err) {
                    console.log('fetchAllData - respuesta no JSON:', text.slice(0, 1000));
                }

                if (result && result.success && result.data && Array.isArray(result.data)) {
                    console.log(`Servidor devolvió ${result.data.length} registros totales`);
                    // Solo guardar en caché si hay datos válidos
                    if (result.data.length > 0) {
                        clientCache.set(cacheKey, result.data);
                    } else {
                        console.log('[Cache] ⚠ No guardando en caché porque hay 0 registros');
                    }
                    return result.data;
                }
                // Mostrar más detalles del error
                if (result && !result.success) {
                    console.log('fetchAllData - error del servidor:', result.error || result.message || 'Error desconocido');
                }
                console.log('fetchAllData - no se recibió data válida', result);
            } catch (error) {
                console.log("Error obteniendo todos los datos (getAllData):", error);
            }
            return null;
        };

        // --- ICONO SVG PARA CARGAR EXCEL ---
        const IconUpload = () => (<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>);

        // --- FUNCIÓN PARA SINCRONIZAR CON GOOGLE SHEETS ---
        const syncWithGoogleSheet = async (rows) => {
            if (!APPS_SCRIPT_URL || APPS_SCRIPT_URL.includes("PEGAR_AQUI")) {
                throw new Error("Configure la URL de Apps Script en el código");
            }

            const response = await fetch(APPS_SCRIPT_URL, {
                method: 'POST',
                mode: 'no-cors',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ rows: rows })
            });

            return { success: true, message: "Datos enviados al servidor" };
        };

        // ============================================
        // COMPONENTE PRINCIPAL
        // ============================================
        function App() {
            // Estado de filtros principales
            const [filterType, setFilterType] = useState('fechas'); // 'fechas' o 'op'
            const [startDate, setStartDate] = useState('');
            const [endDate, setEndDate] = useState('');
            const [opInput, setOpInput] = useState('');
            const [partidaFilter, setPartidaFilter] = useState('');
            
            // Estado de datos
            const [rawData, setRawData] = useState([]);
            const [allDataCache, setAllDataCache] = useState([]); // Cache de todos los datos
            const [isLoading, setIsLoading] = useState(false);
            const [dataLoaded, setDataLoaded] = useState(false);
            
            // Estado de filtros secundarios
            const [selectedGroup, setSelectedGroup] = useState(null);
            const [selectedMachine, setSelectedMachine] = useState(null);

            // Obtener partidas únicas para la OP seleccionada
            const availablePartidas = useMemo(() => {
                if (filterType !== 'op' || !opInput.trim() || !allDataCache || allDataCache.length === 0) return [];
                const opSearch = opInput.trim();
                const partidas = new Set();
                allDataCache.forEach(row => {
                    const rowOP = String(row['OP'] || '').trim();
                    if (rowOP === opSearch) {
                        const partida = String(row['Partida'] || '').trim();
                        if (partida) partidas.add(partida);
                    }
                });
                return Array.from(partidas).sort();
            }, [filterType, opInput, allDataCache]);

            // Obtener grupos únicos de los datos
            const availableGroups = useMemo(() => {
                const groups = new Set();
                rawData.forEach(row => {
                    const group = extractGroup(row['Máquina'] || row['Maquina']);
                    if (group) groups.add(group);
                });
                return Array.from(groups).sort();
            }, [rawData]);

            // Obtener máquinas del grupo seleccionado
            const availableMachines = useMemo(() => {
                if (!selectedGroup) return [];
                const machines = new Set();
                rawData.forEach(row => {
                    const maquina = String(row['Máquina'] || row['Maquina'] || '').trim();
                    const group = extractGroup(maquina);
                    if (group === selectedGroup && maquina) {
                        machines.add(maquina);
                    }
                });
                return Array.from(machines).sort((a, b) => {
                    // Ordenar por número después del guión
                    const numA = parseInt(a.split('-')[1]) || 0;
                    const numB = parseInt(b.split('-')[1]) || 0;
                    return numA - numB;
                });
            }, [rawData, selectedGroup]);

            // Filtrar datos según selección
            const filteredData = useMemo(() => {
                let data = rawData;
                
                if (selectedGroup) {
                    data = data.filter(row => {
                        const group = extractGroup(row['Máquina'] || row['Maquina']);
                        return group === selectedGroup;
                    });
                }
                
                if (selectedMachine) {
                    data = data.filter(row => {
                        const maquina = String(row['Máquina'] || row['Maquina'] || '').trim();
                        return maquina === selectedMachine;
                    });
                }
                
                return data;
            }, [rawData, selectedGroup, selectedMachine]);

            // Detectar columnas de defectos dinámicamente de los datos
            // Son las columnas que empiezan con un número (código de defecto)
            const detectedDefectColumns = useMemo(() => {
                if (rawData.length === 0) return [];
                const availableColumns = Object.keys(rawData[0]);
                const defectCols = availableColumns.filter(col => {
                    // Columnas que empiezan con número y contienen texto (ej: "1.1 Hueco Con Cordon")
                    return /^\d+(\.\d+)*\s+.+/.test(col) && col !== 'TOTAL';
                });
                console.log('Columnas de defectos detectadas:', defectCols.length, defectCols);
                return defectCols;
            }, [rawData]);

            // Función para extraer el nombre sin código
            const extractDefectName = (colName) => {
                const match = colName.match(/^[\d.]+\s+(.+)$/);
                return match ? match[1] : colName;
            };

            // Calcular defectos por máquina
            const defectsByMachine = useMemo(() => {
                const result = {};
                
                filteredData.forEach(row => {
                    const maquina = String(row['Máquina'] || row['Maquina'] || 'SIN MÁQUINA').trim();
                    
                    if (!result[maquina]) {
                        result[maquina] = { total: 0 };
                        detectedDefectColumns.forEach(def => result[maquina][def] = 0);
                    }
                    
                    detectedDefectColumns.forEach(defect => {
                        const count = parseInt(row[defect]) || 0;
                        if (count > 0) {
                            result[maquina][defect] += count;
                            result[maquina].total += count;
                        }
                    });
                });
                
                return result;
            }, [filteredData, detectedDefectColumns]);

            // Obtener defectos que tienen valores > 0
            const activeDefects = useMemo(() => {
                const active = new Set();
                Object.values(defectsByMachine).forEach(machineData => {
                    detectedDefectColumns.forEach(defect => {
                        if (machineData[defect] > 0) active.add(defect);
                    });
                });
                return detectedDefectColumns.filter(d => active.has(d));
            }, [defectsByMachine, detectedDefectColumns]);

            // Calcular totales por defecto
            const totalsByDefect = useMemo(() => {
                const totals = {};
                detectedDefectColumns.forEach(defect => totals[defect] = 0);
                totals.total = 0;
                
                Object.values(defectsByMachine).forEach(machineData => {
                    detectedDefectColumns.forEach(defect => {
                        totals[defect] += machineData[defect] || 0;
                    });
                    totals.total += machineData.total;
                });
                
                return totals;
            }, [defectsByMachine, detectedDefectColumns]);

            // --- FUNCIÓN PARA CARGAR ARCHIVO EXCEL ---
            const handleFileUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                e.target.value = '';

                showLoadingModal(
                    'Cargando archivo...',
                    'Leyendo datos del Excel',
                    `Archivo: ${file.name}`
                );

                const reader = new FileReader();
                reader.onload = async (evt) => {
                    try {
                        updateModalStatus('Procesando archivo Excel...');
                        
                        const bstr = evt.target.result;
                        const wb = XLSX.read(bstr, { type: 'binary' });
                        const wsname = wb.SheetNames[0];
                        const ws = wb.Sheets[wsname];
                        
                        const rawExcelData = XLSX.utils.sheet_to_json(ws, { header: 1 });
                        
                        let headerRowIndex = 1;
                        for (let i = 0; i < Math.min(rawExcelData.length, 10); i++) {
                            const rowStr = JSON.stringify(rawExcelData[i]).toUpperCase();
                            if (rowStr.includes("OP") && (rowStr.includes("PARTIDA") || rowStr.includes("ROLLO"))) {
                                headerRowIndex = i;
                                break;
                            }
                        }

                        const jsonDataRaw = XLSX.utils.sheet_to_json(ws, { range: headerRowIndex, defval: "" });
                        
                        // Obtener el nombre de la columna AA (índice 26) para filtrar filas con "TOTAL"
                        const headers = rawExcelData[headerRowIndex] || [];
                        const colAAName = headers[26]; // Columna AA es índice 26
                        
                        // Filtrar filas que contengan "TOTAL" en la columna AA
                        const jsonData = jsonDataRaw.filter(row => {
                            const cellValue = colAAName ? String(row[colAAName] || '').toUpperCase().trim() : '';
                            return cellValue !== 'TOTAL';
                        });
                        
                        if (jsonData.length === 0) {
                            document.getElementById('modal-title').textContent = '❌ Error';
                            document.getElementById('modal-message').textContent = 'No se encontraron datos válidos';
                            document.getElementById('modal-status').textContent = 'El archivo no contiene datos o el formato es incorrecto';
                            setTimeout(hideLoadingModal, 4000);
                            return;
                        }

                        updateModalStatus(`${jsonData.length} filas encontradas. Sincronizando con la base de datos...`);

                        try {
                            await syncWithGoogleSheet(jsonData);
                            clientCache.clear();
                            
                            document.getElementById('modal-title').textContent = '✅ ¡Completado!';
                            document.getElementById('modal-message').textContent = `Se procesaron ${jsonData.length} filas correctamente`;
                            document.getElementById('modal-status').textContent = 'Los datos han sido sincronizados con la base de datos. Presione Buscar para ver los cambios.';
                            setTimeout(hideLoadingModal, 3000);
                        } catch (syncError) {
                            console.error('Error de sincronización:', syncError);
                            document.getElementById('modal-title').textContent = '❌ Error';
                            document.getElementById('modal-message').textContent = 'Error al sincronizar con la base de datos';
                            document.getElementById('modal-status').textContent = syncError.message || 'Intente nuevamente';
                            setTimeout(hideLoadingModal, 4000);
                        }
                        
                    } catch (error) {
                        console.error(error);
                        document.getElementById('modal-title').textContent = '❌ Error';
                        document.getElementById('modal-message').textContent = 'Error al leer el archivo';
                        document.getElementById('modal-status').textContent = error.message || 'Formato de archivo no válido';
                        setTimeout(hideLoadingModal, 4000);
                    }
                };
                
                reader.onerror = () => {
                    document.getElementById('modal-title').textContent = '❌ Error';
                    document.getElementById('modal-message').textContent = 'Error al leer el archivo';
                    document.getElementById('modal-status').textContent = 'No se pudo leer el archivo seleccionado';
                    setTimeout(hideLoadingModal, 4000);
                };
                
                reader.readAsBinaryString(file);
            };

            // Cargar datos iniciales al montar el componente
            const loadInitialData = useCallback(async () => {
                if (dataLoaded) return;
                
                setIsLoading(true);
                showLoadingModal('Cargando datos...', 'Obteniendo información del servidor', 'Conectando...', 5);

                try {
                    console.log('loadInitialData - Iniciando carga de datos...');
                    const allData = await loadSheetDataFast();
                    console.log('loadInitialData - Datos recibidos:', allData ? allData.length : 'null');
                    
                    if (allData && allData.length > 0) {
                        setAllDataCache(allData);
                        
                        // Debug: mostrar columnas disponibles
                        console.log('loadInitialData - Columnas disponibles:', Object.keys(allData[0]));
                        console.log('loadInitialData - Primera fila:', allData[0]);
                        
                        // Calcular fechas dinámicas basadas en los datos
                        const { startDate: calcStart, endDate: calcEnd } = calculateDateRangeFromData(allData);
                        console.log('loadInitialData - Rango calculado:', calcStart, 'a', calcEnd);
                        setStartDate(calcStart);
                        setEndDate(calcEnd);
                        
                        // Filtrar por las fechas calculadas
                        const filteredByDate = allData.filter(row => {
                            const rawDateStr = row['Día'] || row['Dia'] || row['Day'] || row['Fecha'] || '';
                            const yearFromColumn = parseInt(row['Año'] || row['Anio'] || row['Year'] || 0);
                            const rowDate = parseSheetDate(rawDateStr, yearFromColumn);
                            if (!rowDate) return false;
                            return compareDates(rowDate, calcStart, calcEnd);
                        });
                        
                        console.log('loadInitialData - Registros filtrados:', filteredByDate.length);
                        
                        // Si no hay datos filtrados, mostrar TODOS los datos
                        if (filteredByDate.length === 0) {
                            console.log('loadInitialData - Sin datos en rango, mostrando todos los datos');
                            setRawData(allData);
                            setDataLoaded(true);
                            updateModalStatus(`✓ ${allData.length} registros cargados (sin filtro de fechas)`);
                        } else {
                            setRawData(filteredByDate);
                            setDataLoaded(true);
                            updateModalStatus(`✓ ${filteredByDate.length} registros cargados (${calcStart} a ${calcEnd})`);
                        }
                    } else {
                        console.log('loadInitialData - No se recibieron datos del servidor');
                        updateModalStatus('No se encontraron datos en el servidor');
                    }
                } catch (error) {
                    console.error('Error cargando datos:', error);
                    updateModalStatus('Error al cargar datos: ' + error.message);
                } finally {
                    setTimeout(() => {
                        setIsLoading(false);
                        hideLoadingModal();
                    }, 500);
                }
            }, [dataLoaded]);

            // Cargar datos al montar el componente
            useEffect(() => {
                loadInitialData();
            }, [loadInitialData]);

            // Manejar búsqueda - OPTIMIZADO con diagnóstico
            const handleSearch = useCallback(async () => {
                setIsLoading(true);
                setSelectedGroup(null);
                setSelectedMachine(null);
                
                showLoadingModal(
                    'Consultando datos...',
                    filterType === 'fechas' 
                        ? `Buscando registros del ${startDate} al ${endDate}`
                        : `Buscando registros de OP ${opInput}`,
                    'Conectando con la base de datos...',
                    15
                );

                try {
                    let data = null;
                    
                    if (filterType === 'op' && opInput.trim()) {
                        // Buscar por OP usando datos del caché local para preservar columnas
                        updateModalStatus('Obteniendo datos de OP...');
                        
                        // Usar los datos del caché local en lugar de llamar al servidor
                        // para evitar problemas con la serialización de columnas
                        let sourceData = allDataCache;
                        
                        if (!sourceData || sourceData.length === 0) {
                            // Si no hay caché, cargar todos los datos primero
                            updateModalStatus('Cargando datos del servidor...');
                            sourceData = await loadSheetDataFast();
                            if (sourceData && sourceData.length > 0) {
                                setAllDataCache(sourceData);
                            }
                        }
                        
                        if (sourceData && sourceData.length > 0) {
                            const opSearch = opInput.trim();
                            // Filtrar por OP de forma flexible (como string o número)
                            data = sourceData.filter(row => {
                                const rowOP = String(row['OP'] || '').trim();
                                return rowOP === opSearch;
                            });
                            
                            // Filtrar por Partida si se seleccionó una
                            if (partidaFilter) {
                                data = data.filter(row => {
                                    const rowPartida = String(row['Partida'] || '').trim();
                                    return rowPartida === partidaFilter;
                                });
                            }
                            
                            console.log(`Búsqueda OP ${opSearch}: encontrados ${data.length} de ${sourceData.length} registros`);
                            if (data.length > 0) {
                                console.log('Primera fila encontrada:', data[0]);
                                console.log('Columnas disponibles:', Object.keys(data[0]));
                            }
                            
                            updateModalStatus(`✓ ${data.length} registros encontrados para OP ${opSearch}`);
                        }
                    } else if (filterType === 'fechas') {
                        // ESTRATEGIA: Primero getAllData, luego filtrar localmente para asegurar todos los datos
                        updateModalStatus('Descargando todos los datos...');
                        console.log('SEARCH startDate=', startDate, 'endDate=', endDate);
                        
                        // Limpiar caché para forzar recarga fresca
                        clientCache.clear();
                        
                        // Obtener TODOS los datos y filtrar localmente
                        const allData = await loadSheetDataFast();
                        
                        if (allData && allData.length > 0) {
                            console.log(`Total registros del servidor: ${allData.length}`);
                            
                            // Mostrar todas las máquinas únicas para diagnóstico
                            const allMachines = [...new Set(allData.map(r => r['Máquina'] || r['Maquina'] || 'N/A'))];
                            console.log('Todas las máquinas en el sheet:', allMachines);
                            
                            // Mostrar todos los grupos únicos
                            const allGroups = [...new Set(allMachines.map(m => extractGroup(m)).filter(g => g))];
                            console.log('Todos los grupos en el sheet:', allGroups);
                            
                            // Filtrar por fechas localmente
                            updateModalStatus(`Filtrando ${allData.length} registros por fechas...`);
                            data = allData.filter(row => {
                                const rawDateStr = row['Día'] || row['Dia'] || row['Day'] || row['Fecha'] || '';
                                const yearFromColumn = parseInt(row['Año'] || row['Anio'] || row['Year'] || 0);
                                const rowDate = parseSheetDate(rawDateStr, yearFromColumn);
                                if (!rowDate) return false;
                                return compareDates(rowDate, startDate, endDate);
                            });
                            
                            console.log(`Registros filtrados: ${data.length}`);
                            
                            // Mostrar máquinas filtradas para diagnóstico
                            const filteredMachines = [...new Set(data.map(r => r['Máquina'] || r['Maquina'] || 'N/A'))];
                            console.log('Máquinas en rango de fechas:', filteredMachines);
                            
                            const filteredGroups = [...new Set(filteredMachines.map(m => extractGroup(m)).filter(g => g))];
                            console.log('Grupos en rango de fechas:', filteredGroups);
                        }
                    }
                    
                    if (data && data.length > 0) {
                        setRawData(data);
                        updateModalStatus(`✓ ${data.length} registros encontrados`);
                    } else {
                        setRawData([]);
                        updateModalStatus('No se encontraron registros para el rango especificado');
                    }
                } catch (error) {
                    console.error('Error en búsqueda:', error);
                    updateModalStatus('Error al consultar datos: ' + error.message);
                } finally {
                    setTimeout(() => {
                        setIsLoading(false);
                        hideLoadingModal();
                    }, 1000);
                }
            }, [filterType, startDate, endDate, opInput, partidaFilter, allDataCache]);

            // Manejar cambio de grupo
            const handleGroupClick = (group) => {
                if (selectedGroup === group) {
                    setSelectedGroup(null);
                    setSelectedMachine(null);
                } else {
                    setSelectedGroup(group);
                    setSelectedMachine(null);
                }
            };

            // Manejar cambio de máquina
            const handleMachineClick = (machine) => {
                if (selectedMachine === machine) {
                    setSelectedMachine(null);
                } else {
                    setSelectedMachine(machine);
                }
            };

            // Exportar a Excel con ExcelJS
            const handleExportExcel = async () => {
                try {
                    if (!window.ExcelJS) {
                        alert('La librería de Excel no se ha cargado. Por favor, recarga la página.');
                        return;
                    }
                    
                    const workbook = new window.ExcelJS.Workbook();
                    const worksheet = workbook.addWorksheet("Defectos");
                    
                    // Agregar título
                    const titleRow = worksheet.addRow(["CONTROL DE INSPECCIÓN DE CALIDAD T-CRUDO"]);
                    titleRow.font = { bold: true, size: 14, name: 'Calibri' };
                    
                    // Agregar subtítulo
                    const subtitleRow = worksheet.addRow(["Defectos por Máquina"]);
                    subtitleRow.font = { bold: true, size: 11, name: 'Calibri' };
                    
                    // Fila vacía
                    worksheet.addRow([]);
                    
                    // Preparar datos
                    const machines = Object.keys(defectsByMachine).sort();
                    const headers = ["Defecto", ...machines, "TOTAL", "%Part"];
                    
                    // Agregar encabezados
                    const headerRow = worksheet.addRow(headers);
                    headerRow.font = { bold: true, color: { argb: 'FF000000' } };
                    headerRow.fill = {
                        type: 'pattern',
                        pattern: 'solid',
                        fgColor: { argb: 'FFD3D3D3' }
                    };
                    headerRow.alignment = { horizontal: 'center', vertical: 'center', wrapText: true };
                    
                    // Aplicar bordes al encabezado
                    headerRow.eachCell(cell => {
                        cell.border = {
                            top: { style: 'thin' },
                            left: { style: 'thin' },
                            bottom: { style: 'thin' },
                            right: { style: 'thin' }
                        };
                    });
                    
                    // Agregar datos de defectos ordenados por TOTAL
                    activeDefects
                        .sort((a, b) => (totalsByDefect[b] || 0) - (totalsByDefect[a] || 0))
                        .forEach((defect, index) => {
                            const defectTotal = totalsByDefect[defect] || 0;
                            const percentage = totalsByDefect.total > 0 ? ((defectTotal / totalsByDefect.total) * 100).toFixed(2) : 0;
                            const row = [extractDefectName(defect)];
                            machines.forEach(machine => {
                                row.push(defectsByMachine[machine][defect] > 0 ? defectsByMachine[machine][defect] : '-');
                            });
                            row.push(defectTotal > 0 ? defectTotal : '-');
                            row.push(defectTotal > 0 ? `${percentage}%` : '-');
                            
                            const dataRow = worksheet.addRow(row);
                            
                            // Alternar colores de filas
                            if (index % 2 === 1) {
                                dataRow.eachCell((cell, colNumber) => {
                                    cell.fill = {
                                        type: 'pattern',
                                        pattern: 'solid',
                                        fgColor: { argb: 'FFF2F2F2' }
                                    };
                                });
                            }
                            
                            // Aplicar bordes y alineación
                            dataRow.eachCell((cell, colNumber) => {
                                cell.border = {
                                    top: { style: 'thin' },
                                    left: { style: 'thin' },
                                    bottom: { style: 'thin' },
                                    right: { style: 'thin' }
                                };
                                
                                // Alinear primera columna a la izquierda, resto al centro
                                if (colNumber === 1) {
                                    cell.alignment = { horizontal: 'left', vertical: 'center' };
                                } else {
                                    cell.alignment = { horizontal: 'center', vertical: 'center' };
                                }
                                
                                // Destacar columna TOTAL
                                if (colNumber === headers.length) {
                                    cell.font = { bold: true, color: { argb: 'FF0070C0' } };
                                    cell.fill = {
                                        type: 'pattern',
                                        pattern: 'solid',
                                        fgColor: { argb: 'FFC6E0B4' }
                                    };
                                }
                            });
                        });
                    
                    // Agregar fila de totales
                    const totalRow = ["TOTAL"];
                    machines.forEach(machine => {
                        totalRow.push(defectsByMachine[machine].total);
                    });
                    totalRow.push(totalsByDefect.total);
                    totalRow.push("100%");
                    
                    const footerRow = worksheet.addRow(totalRow);
                    footerRow.font = { bold: true };
                    footerRow.fill = {
                        type: 'pattern',
                        pattern: 'solid',
                        fgColor: { argb: 'FFD3D3D3' }
                    };
                    footerRow.alignment = { horizontal: 'center', vertical: 'center' };
                    
                    // Aplicar bordes a la fila de totales
                    footerRow.eachCell(cell => {
                        cell.border = {
                            top: { style: 'thin' },
                            left: { style: 'thin' },
                            bottom: { style: 'thin' },
                            right: { style: 'thin' }
                        };
                    });
                    
                    // Configurar ancho de columnas
                    worksheet.columns = [
                        { width: 25 },
                        ...machines.map(() => ({ width: 12 })),
                        { width: 12 },
                        { width: 12 }
                    ];
                    
                    // Generar y descargar archivo
                    const buffer = await workbook.xlsx.writeBuffer();
                    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `Defectos_Maquina_${new Date().toLocaleDateString('es-ES')}.xlsx`;
                    link.click();
                    window.URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('Error al exportar Excel:', error);
                    alert('Error al generar el archivo Excel: ' + error.message);
                }
            };

            return (
                <div className="max-w-7xl mx-auto px-2 py-3">
                    {/* Encabezado con Navegación */}
                    <header className="flex flex-wrap items-center justify-between gap-3 mb-4">
                        <div className="text-left">
                            <h1 className="text-xl font-bold text-gray-800 tracking-tight">
                                CONTROL DE INSPECCIÓN DE CALIDAD T-CRUDO
                            </h1>
                            <h2 className="text-sm text-gray-600 mt-1 hidden print:block">Defectos por Máquina</h2>
                        </div>
                        
                        {/* Pestañas de Navegación */}
                        <nav className="flex flex-wrap items-center gap-2 print:hidden">
                            <a 
                                href="principales_defectos.html" 
                                className="px-2.5 py-1 text-sm font-medium text-gray-600 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors"
                            >
                                📊 Principales Defectos
                            </a>
                            <a 
                                href="defecto_maquina.html" 
                                className="px-2.5 py-1 text-sm font-medium text-white bg-blue-600 rounded-md transition-colors"
                            >
                                🔧 Defectos xMáquina
                            </a>
                            <a 
                                href="produccion_articulo.html" 
                                className="px-2.5 py-1 text-sm font-medium text-gray-600 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors"
                            >
                                📦 Producción xArtículo
                            </a>
                            <a 
                                href="defectos_inspeccion.html" 
                                className="px-2.5 py-1 text-sm font-medium text-gray-600 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors"
                            >
                                🔍 Defectos Inspecc.
                            </a>
                        </nav>
                    </header>

                    {/* Filtros Principales */}
                    <div className="bg-white rounded-lg shadow-sm border border-gray-200 px-4 py-2 mb-3 print:hidden">
                        <div className="flex flex-wrap items-center justify-between gap-4">
                            <div className="flex flex-wrap items-center gap-4">
                                {/* Selector de tipo de filtro */}
                                <div className="flex items-center gap-4 border-r border-gray-200 pr-4">
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input
                                            type="radio"
                                            name="filterType"
                                            value="fechas"
                                            checked={filterType === 'fechas'}
                                            onChange={(e) => setFilterType(e.target.value)}
                                            className="w-4 h-4 text-blue-600"
                                        />
                                        <span className="text-sm font-medium text-gray-700">FECHAS</span>
                                    </label>
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input
                                            type="radio"
                                            name="filterType"
                                            value="op"
                                            checked={filterType === 'op'}
                                            onChange={(e) => setFilterType(e.target.value)}
                                            className="w-4 h-4 text-blue-600"
                                        />
                                        <span className="text-sm font-medium text-gray-700">OP</span>
                                    </label>
                                </div>

                                {/* Campos de filtro según tipo */}
                                {filterType === 'fechas' ? (
                                    <div className="flex items-center gap-4">
                                        <div className="flex items-center gap-2">
                                            <label className="text-sm font-medium text-gray-700">Inicio</label>
                                            <input
                                                type="date"
                                                value={startDate}
                                                onChange={(e) => setStartDate(e.target.value)}
                                                className="px-2 py-1.5 border border-gray-300 rounded-md text-xs focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                            />
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <label className="text-sm font-medium text-gray-700">Fin</label>
                                            <input
                                                type="date"
                                                value={endDate}
                                                onChange={(e) => setEndDate(e.target.value)}
                                                className="px-2 py-1.5 border border-gray-300 rounded-md text-xs focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                            />
                                        </div>
                                    </div>
                                ) : (
                                    <div className="flex items-center gap-2">
                                        <label className="text-sm font-medium text-gray-700">OP</label>
                                        <input
                                            type="text"
                                            value={opInput}
                                            onChange={(e) => {
                                                // Permitir solo números
                                                const val = e.target.value.replace(/\D/g, '');
                                                setOpInput(val);
                                                setPartidaFilter('');
                                            }}
                                            placeholder="Ej: 40768"
                                            maxLength={10}
                                            className="w-28 px-2 py-1.5 border border-gray-300 rounded-md text-xs text-center font-mono focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                        />
                                        {availablePartidas.length > 0 && (
                                            <>
                                                <label className="text-sm font-medium text-gray-700">Partida</label>
                                                <select
                                                    value={partidaFilter}
                                                    onChange={(e) => setPartidaFilter(e.target.value)}
                                                    className="px-2 py-1.5 border border-gray-300 rounded-md text-xs focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                                >
                                                    <option value="">Todas</option>
                                                    {availablePartidas.map(p => (
                                                        <option key={p} value={p}>{p}</option>
                                                    ))}
                                                </select>
                                            </>
                                        )}
                                    </div>
                                )}

                                {/* Botón de búsqueda */}
                                <button
                                    onClick={handleSearch}
                                    disabled={isLoading || (filterType === 'op' && opInput.trim().length === 0)}
                                    className="p-2 bg-blue-600 text-white rounded-full hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors flex items-center justify-center w-10 h-10"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <circle cx="11" cy="11" r="8"/>
                                        <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                                    </svg>
                                </button>

                                {/* Info de registros */}
                                {rawData.length > 0 && (
                                    <div className="text-sm text-gray-500">
                                        <span className="font-semibold text-blue-600">{filteredData.length}</span> registros
                                    </div>
                                )}
                            </div>

                            {/* Botón de impresión a la derecha */}
                            {Object.keys(defectsByMachine).length > 0 && (
                                <div className="flex items-center gap-2">
                                    <button
                                        onClick={handleExportExcel}
                                        className="p-2 bg-green-600 text-white rounded-full hover:bg-green-700 transition-colors flex items-center justify-center w-10 h-10"
                                        title="Descargar Excel"
                                    >
                                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                                        </svg>
                                    </button>
                                    <button
                                        onClick={() => window.print()}
                                        className="p-2 bg-gray-600 text-white rounded-full hover:bg-gray-700 transition-colors flex items-center justify-center w-10 h-10"
                                        title="Imprimir"
                                    >
                                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                            <polyline points="6 9 6 2 18 2 18 9"/>
                                            <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/>
                                            <rect x="6" y="14" width="12" height="8"/>
                                        </svg>
                                    </button>
                                    <label 
                                        title="Cargar Excel" 
                                        className="p-2 bg-blue-600 text-white rounded-full hover:bg-blue-700 transition-colors flex items-center justify-center w-10 h-10 cursor-pointer"
                                    >
                                        <IconUpload />
                                        <input type="file" accept=".xlsx, .xls, .csv" onChange={handleFileUpload} className="hidden" />
                                    </label>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Contenedor con 2 columnas */}
                    <div className="grid grid-cols-1 lg:grid-cols-6 gap-2" style={{ height: 'calc(100vh - 180px)' }}>
                        {/* Filtros Secundarios - COLUMNA IZQUIERDA */}
                        {rawData.length > 0 && (
                            <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-3 overflow-y-auto print:hidden" style={{ maxHeight: 'calc(100vh - 180px)' }}>
                            {/* Grupos */}
                            <div className="mb-3">
                                <label className="block text-xs font-medium text-gray-500 mb-1">Grupos</label>
                                <div className="grid grid-cols-2 gap-1">
                                    {availableGroups.map(group => (
                                        <button
                                            key={group}
                                            onClick={() => handleGroupClick(group)}
                                            className={`filter-btn px-2 py-1 rounded-md text-xs font-medium border transition-all ${
                                                selectedGroup === group
                                                    ? 'bg-blue-600 text-white border-blue-600'
                                                    : 'bg-white text-gray-700 border-blue-400 hover:border-blue-600'
                                            }`}
                                        >
                                            {group}
                                        </button>
                                    ))}
                                </div>
                            </div>

                            {/* Máquinas (solo si hay grupo seleccionado) */}
                            {selectedGroup && availableMachines.length > 0 && (
                                <div>
                                    <label className="block text-xs font-medium text-gray-500 mb-1">Máquina</label>
                                    <div className="grid grid-cols-2 gap-1">
                                        {availableMachines.map(machine => (
                                            <button
                                                key={machine}
                                                onClick={() => handleMachineClick(machine)}
                                                className={`filter-btn px-2 py-1 rounded-md text-xs font-medium border transition-all ${
                                                    selectedMachine === machine
                                                        ? 'bg-green-600 text-white border-green-600'
                                                        : 'bg-white text-gray-700 border-green-500 hover:border-green-600'
                                                }`}
                                            >
                                                {machine}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {/* Tabla de Resultados - COLUMNA DERECHA */}
                    <div className="lg:col-span-5 overflow-hidden" style={{ maxHeight: 'calc(100vh - 180px)' }}>
                        {Object.keys(defectsByMachine).length > 0 ? (
                            <div className="bg-white rounded-lg shadow-sm border border-gray-200 overflow-auto h-full">
                                    <table className="text-sm">
                                    <thead>
                                        <tr className="bg-gray-100">
                                            <th className="px-2 py-1 text-left font-bold text-gray-700 border-b border-r sticky left-0 bg-gray-100 whitespace-nowrap z-10">
                                                Defecto
                                            </th>
                                            {Object.keys(defectsByMachine)
                                                .sort()
                                                .map(machine => (
                                                    <th key={machine} className="px-1.5 py-1 text-center font-bold text-gray-600 border-b text-xs whitespace-nowrap">
                                                        {machine}
                                                    </th>
                                                ))}
                                            <th className="px-2 py-1 text-center font-bold text-gray-800 border-b border-l bg-blue-50">
                                                TOTAL
                                            </th>
                                            <th className="px-2 py-1 text-center font-bold text-gray-800 border-b border-l bg-purple-50">
                                                %Part
                                            </th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {(() => {
                                            let accumulatedPercentage = 0;
                                            return activeDefects
                                                .sort((a, b) => (totalsByDefect[b] || 0) - (totalsByDefect[a] || 0))
                                                .map((defect, idx) => {
                                                    const defectTotal = totalsByDefect[defect] || 0;
                                                    const percentage = totalsByDefect.total > 0 ? ((defectTotal / totalsByDefect.total) * 100).toFixed(2) : 0;
                                                    accumulatedPercentage += parseFloat(percentage);
                                                    const isLessThan85 = accumulatedPercentage < 85;
                                                    const rowBgClass = isLessThan85 ? 'bg-orange-100' : (idx % 2 === 0 ? 'bg-white' : 'bg-gray-50');
                                                    
                                                    return (
                                                        <tr key={defect} className={rowBgClass}>
                                                            <td className="px-2 py-1 font-medium text-gray-800 border-r sticky left-0 bg-inherit whitespace-nowrap z-10">
                                                                {extractDefectName(defect)}
                                                            </td>
                                                            {Object.entries(defectsByMachine)
                                                                .sort(([a], [b]) => a.localeCompare(b))
                                                                .map(([machine, data]) => (
                                                                    <td key={machine} className="px-1.5 py-1 text-center text-gray-600">
                                                                        {data[defect] > 0 ? data[defect] : '-'}
                                                                    </td>
                                                                ))}
                                                            <td className="px-2 py-1 text-center font-bold text-blue-700 border-l bg-blue-50">
                                                                {defectTotal > 0 ? defectTotal : '-'}
                                                            </td>
                                                            <td className="px-2 py-1 text-center font-bold text-purple-700 border-l bg-purple-50">
                                                                {defectTotal > 0 ? `${percentage}%` : '-'}
                                                            </td>
                                                        </tr>
                                                    );
                                                });
                                        })()}
                                    </tbody>
                                    <tfoot>
                                        <tr className="bg-gray-200 font-bold">
                                            <td className="px-2 py-1 text-gray-800 border-t border-r sticky left-0 bg-gray-200 whitespace-nowrap z-10">
                                                TOTAL
                                            </td>
                                            {Object.keys(defectsByMachine)
                                                .sort()
                                                .map(machine => (
                                                    <td key={machine} className="px-1.5 py-1 text-center text-gray-700 border-t">
                                                        {defectsByMachine[machine].total}
                                                    </td>
                                                ))}
                                            <td className="px-2 py-1 text-center text-blue-800 border-t border-l bg-blue-100">
                                                {totalsByDefect.total}
                                            </td>
                                            <td className="px-2 py-1 text-center text-purple-800 border-t border-l bg-purple-100">
                                                100%
                                            </td>
                                        </tr>
                                    </tfoot>
                                </table>
                        </div>
                    ) : rawData.length === 0 && !isLoading ? (
                        <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-12 text-center">
                            <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" className="mx-auto text-gray-300 mb-4">
                                <circle cx="11" cy="11" r="8"/>
                                <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                            </svg>
                            <p className="text-gray-500">Seleccione los filtros y presione <strong>Buscar</strong> para ver los datos</p>
                        </div>
                    ) : null}
                    </div>
                    </div>
                </div>
            );
        }

        // Renderizar la aplicación
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
